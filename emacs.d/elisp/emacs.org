(defconst my/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))

(defun my/emacs-subdirectory (d) (expand-file-name d ha/emacs-directory))
;; first time running
(let* ((subdirs '("elisp" "backups" "snippets" "ac-dict"))
       (fulldirs (mapcar (lambda (d) (my/emacs-subdirectory d)) subdirs)))
  (dolist (dir fulldirs)
    (when (not (file-exists-p dir))
      (message "Make directory: %s" dir)
      (make-directory dir))))

;; customization

(setq custom-file (expand-file-name "custom.el" ha/emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))

;; set up load path
(add-to-list 'load-path (ha/emacs-subdirectory "elisp"))

;; load up ha enhanced collections (eg 'cl init-support')
(require 'cl)
(require 'init-support)

;; package manager
(require 'package)

(setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                         ("gnu"       . "http://elpa.gnu.org/packages/")
                         ("melpa"     . "http://melpa.milkbox.net/packages/")
                         ("marmalade" . "http://marmalade-repo.org/packages/")))

(package-initialize)

;; package install
;;(defun packages-install (packages)
;;  "Given a list of packages, this will install them from the standard locations."
;;  (let ((to-install (inverse-filter 'package-installed-p packages)))
;;    (when to-install
;;      (package-refresh-contents)
;;      (dolist (it to-install)
;;          (package-install it)
;;      (delete-other-windows)))))

;; auto install select packages; easy lazy-laoading
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)

;; spaces
(setq-default indent-tabs-mode nil)
(setq tab-width 2)

;; indent := complete

(setq-default tab-always-indent 'complete)


;; encryption (.gpg)
;;(setq epa-file-select-keys 2)
;;(setq epa-file-cache-passphrase-for-symmetric-encryption t)

;; minimalize a la ha
(setq initial-scratch-message "") ;; Uh, I know what Scratch is for
(setq visible-bell t)             ;; Get rid of the beeps

(when (window-system)
  (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
  (scroll-bar-mode -1))            ;; Scrollbars are waste screen estate


;; mode-line
;; (require 'init-mode-line)

;; whitespace
;;(use-package whitespace
;;  :bind ("C-c T w" . whitespace-mode)
;;  :init
;;  (setq whitespace-line-column nil
;;        whitespace-display-mappings '((space-mark 32 [183] [46])
;;                                      (newline-mark 10 [9166 10])
;;                                      (tab-mark 9 [9654 9] [92 9])))
;;  :config
;;  (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
;;  (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
;;  (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
;;  :diminish whitespace-mode)
;; trim trail save-hook
;;(add-hook 'before-save-hook 'delete-trailing-whitespace)

;; autowrap eol / region
;;(use-package fill
;;  :bind ("C-c T f" . auto-fill-mode)
;;  :init (add-hook 'org-mode-hook 'turn-on-auto-fill)
;;  :diminish auto-fill-mode)

;; hydra
;; https://github.com/abo-abo/hydra
(use-package hydra
  :ensure t
  :config
  (hydra-add-font-lock))

;; windmove // window-resize / move-splitter

(require 'windmove)

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))

(defhydra hydra-splitter (global-map "<f9>")
  "splitter"
  ("<left>" hydra-move-splitter-left)
  ("<down>" hydra-move-splitter-down)
  ("<up>" hydra-move-splitter-up)
  ("<right>" hydra-move-splitter-right))

;; guide-key
;;(use-package guide-key
;;  :ensure t
;;  :init    (setq guide-key/guide-key-sequence
;;                 '("C-x r"     ; rectanges and registers
;;                   "C-x 4"     ; window commands
;;                   "M-s h"     ; hi-lock highlighting
;;                   "C-x w"     ; alternative to M-s ...
;;                   "C-c @"     ; hs-hide-show mode
;;                   "C-c p"     ; projectile
;;                   "<f2>"
;;                   "<f9>"
;;                   (org-mode "C-c C-x")))
;;  :config  (guide-key-mode 1)
;;  :diminish guide-key-mode)


;; ??
;;(setq guide-key/guide-key-sequence '("C-x"))
;;(setq guide-key/recursive-key-sequence-flag t)


;; F - k

;;    F1 - Help? Isn’t Control-H good enough?
;;    F2 - Special odd, little-used characters that I have to think about before remembering what its binding.
;;    F3 - Define a keyboard macro
;;    F4 - Replay a keyboard macro
;;    F5 - Use org-mode’s Mark Ring feature globally
;;    F6 - Open to temporary, changeable commands…
;;    F7 - Switch to another window … Control goes the other way.
;;    F8 - Switch to buffer
;;    F9 - My extension (replacement?) for C-c for changing colors and other odd bindings that I actually don’t use that often.

;;(global-set-key (kbd "<f5>") 'org-mark-ring-push)
;;(global-set-key (kbd "C-<f5>") 'org-mark-ring-goto)
;;(global-set-key (kbd "<f7>") 'other-window)
;;(global-set-key (kbd "C-<f7>") (lambda () (interactive) (other-window -1)))
;; IDO switch buffer / kpm-list
(global-set-key (kbd "<f8>") 'ido-switch-buffer)
(global-set-key (kbd "S-<f8>") 'ibuffer)
(use-package kpm-list
  :ensure t
  :bind ("S-<f8>" . kpm-list)
        ("C-x C-b" . kpm-list))
;; f2
(require 'init-f2_')

;; windowing
;;(global-unset-key (kbd "C-c w"))
;;(global-set-key (kbd "C-c w r") 'ha/window-standard-size)
;;(make-variable-buffer-loacl 'window-width-original')

;; ha/window-standard-size
;;(defun ha/window-standard-size (arg)
;;  "Sets the size of the current window to 80 characters, unless
;;it already is 80 characters, in which case, set it back to its
;;previous size. A prefix ARG can be given to set the window to a
;;particular width."
;;  (interactive "p")
;;
;;  ;; If not already set, let's store the current window width in our
;;  ;; buffer-local variable.
;;  (if (not (local-variable-p 'window-width-original))
;;      (setq window-width-original (window-width)))
;;
;;  ;; The 'goal' is 80 unless we get a better argument, C-u 60 ...
;;  (let* ((goal-width (if (> arg 8) arg 80))
;;         (new-width (- goal-width (window-width))))
;;
;;    (if (= new-width 0)    ; Already enlarged? Restore:
;;        (enlarge-window-horizontally (- window-width-original goal-width))
;;      (enlarge-window-horizontally new-width))))


;; ace-window // winner-mode //eyebrowse
;;(use-package ace-window
;;  :ensure t
;;  :init
;;    (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
;;    (global-set-key (kbd "C-x o") 'ace-window)
;;  :diminish ace-window-mode)
;;(use-package winner
;;  :ensure t
;;  :init (winner-mode 1))
;;  (use-package eyebrowse
;;     :ensure t
;;     :init   (eyebrowse-mode t))
;;
;; highlighting
;;M-s h .
;;    highlight-symbol-at-point
;;M-s h l
;;    highlight-lines-matching-regexp
;;M-s h p
;;    highlight-phrase
;;M-s h r
;;    highlight-regexp
;;M-s h u
;;    unhighlight-regexp

;; ha/highlite-logs
;;(defun ha/highlite-logs ()
;;  "Highlight certain lines in specific files. Currently, only log files are supported."
;;  (interactive)
;;  (when (equal "log" (file-name-extension (buffer-file-name)))
;;        (hi-lock-mode 1)
;;        (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
;;        (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b)))

;; .log hook
;;(add-hook 'find-file-hook 'ha/highlite-logs)

;; ha/sprint-retrospective highlighting
;;(defun ha/sprint-retrospective-highlighting ()
;;  "Highlights the good, the bad and the improvements to make when taking notes."
;;  (interactive)
;;  (hi-lock-mode t)
;;  (highlight-lines-matching-regexp "^   [-*] " 'hi-black-b)
;;  (highlight-phrase "TODO:?" 'hi-black-b)
;;  (highlight-regexp "(?Good)?:?" 'hi-green-b)
;;  (highlight-regexp "(?Bad)?:?" 'hi-red-b)
;;  (highlight-regexp "Imp\\(rove\\)?:" 'hi-blue-b))

;; fancy-narrow
;;https://github.com/Malabarba/fancy-narrow
;;(use-package fancy-narrow
;;  :ensure t
;;  :config
;;  (defun ha/highlight-block ()
;;    "Highlights a 'block' in a buffer defined by the first blank
;;     line before and after the current cursor position. Uses the
;;     'fancy-narrow' mode to high-light the block."
;;    (interactive)
;;    (let (cur beg end)
;;      (setq cur (point))
;;      (setq end (or (re-search-forward  "^\s*$" nil t) (point-max)))
;;      (goto-char cur)
;;      (setq beg (or (re-search-backward "^\s*$" nil t) (point-min)))
;;      (fancy-narrow-to-region beg end)
;;      (goto-char cur)))
;;
;;  (defun ha/highlight-section (num)
;;    "If some of the buffer is highlighted with the `fancy-narrow'
;;     mode, then un-highlight it by calling `fancy-widen'.
;;
;;     If region is active, call `fancy-narrow-to-region'.
;;
;;     If NUM is 0, highlight the current block (delimited by blank
;;     lines). If NUM is positive or negative, highlight that number
;;     of lines.  Otherwise, called `fancy-narrow-to-defun', to
;;     highlight current function."
;;    (interactive "p")
;;    (cond
;;     ((fancy-narrow-active-p)  (fancy-widen))
;;     ((region-active-p)        (fancy-narrow-to-region (region-beginning) (region-end)))
;;     ((= num 0)                (ha/highlight-block))
;;     ((= num 1)                (fancy-narrow-to-defun))
;;     (t                        (progn (ha/expand-region num)
;;                                      (fancy-narrow-to-region (region-beginning) (region-end))))))
;;
;;  :bind ("C-M-+" . ha/highlight-section))


;; endless parenthesis narrow keybindings
;;(defun narrow-or-widen-dwim (p)
;;  "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
;;Intelligently means: region, subtree, or defun, whichever applies
;;first.
;;
;;With prefix P, don't widen, just narrow even if buffer is already
;;narrowed."
;;  (interactive "P")
;;  (declare (interactive-only))
;;  (cond ((and (buffer-narrowed-p) (not p)) (widen))
;;        ((region-active-p)
;;         (narrow-to-region (region-beginning) (region-end)))
;;        ((derived-mode-p 'org-mode) (org-narrow-to-subtree))
;;        (t (narrow-to-defun))))
;;
;;(global-set-key (kbd "C-x n x") 'narrow-or-widen-dwim)

;; search / visual regex
;;(bind-keys :map isearch-mode-map
;;           ("<left>"  . isearch-repeat-backward)
;;           ("<right>" . isearch-repeat-forward)
;;           ("<up>"    . isearch-ring-retreat)
;;           ("<down>"  . isearch-ring-advance))
;;
;;           (use-package visual-regexp
;;             :ensure t
;;             :init
;;             (use-package visual-regexp-steroids :ensure t)
;;
;;             :bind (("C-c r" . vr/replace)
;;                    ("C-c q" . vr/query-replace))
;;
;;             ;; if you use multiple-cursors, this is for you:
;;             :config (use-package  multiple-cursors
;;                       :bind ("C-c m" . vr/mc-mark)))

;; hungry delete
;; http://endlessparentheses.com//hungry-delete-mode.html
;;M-\
;;    Removes all spaces
;;M-SPC
;;    Removes extra spaces, leaving just one
;;M-^
;;    Joins current line with previous line (doesn’t matter where the point is on the line)
;;M-- M-1 M-SPC
;;    Joins next line to this one (if point at end of line) separated by a space … quite the chording, eh?

;; flycheck
;; https://github.com/flycheck/flycheck
(use-package flycheck
  :ensure t
  :init
  (add-hook 'after-init-hook 'global-flycheck-mode)
  :config
  (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

;; ctags
;; apt-get install -y exuberant-ctags .. ctags -ER .
;;--langdef=org
;;--langmap=org:.org
;;--regex-org=/^\*+[ \t]+([a-zA-Z0-9_ ]+)/\1/d,definition/
;;(require 'etags)
;;(use-package ctags-update
;;  :ensure t
;;  :config
;;  (add-hook 'prog-mode-hook  'turn-on-ctags-auto-update-mode)
;;  :diminish ctags-auto-update-mode)

;; idomenu(+mouse)
(use-package idomenu
;;  :ensure t
;;  :bind ("C-c i" . idomenu))
;;(use-package imenu+
;;  :ensure t
;;  :init (add-hook 'prog-mode-hook 'imenup-add-defs-to-menubar)
;;        (add-hook 'org-mode-hook  'imenup-add-defs-to-menubar))

;; helm
;;(use-package helm
;;  :bind (("C-c M-i" . helm-imenu)))
;;(use-package guide-key
;;  :init (add-to-list 'guide-key/guide-key-sequence "C-x c"))

;; etags-select and ido
;; https://www.emacswiki.org/emacs/EtagsSelect#toc3
(use-package ido
  :config
  (defun ido-find-tag ()
    "Find a tag using ido"
    (interactive)
    (tags-completion-table)
    (let (tag-names)
      (mapatoms (lambda (x)
                  (push (prin1-to-string x t) tag-names))
                tags-completion-table)
      (find-tag (ido-completing-read "Tag: " tag-names))))

  (global-set-key (kbd "C-c I") 'ido-find-tag))

;; find-tags xref
;;(global-set-key (kbd "M-.") 'find-tag)
;;(global-set-key (kbd "C-M-.") 'find-tag-regexp)
;;(global-set-key (kbd "M-,") 'pop-tag-mark)
;;(global-set-key (kbd "M-i") 'imenu-anywhere)
;; "this prompt needs to go away"
;;(setq tags-add-tables nil)

;; ha/hideshow
;; https://www.emacswiki.org/emacs/HideShow
;; folding / wrappers
;;(defun ha/hs-show-all ()
;;  (interactive)
;;  (hs-minor-mode 1)
;;  (hs-show-all))
;;
;;(defun ha/hs-hide-all ()
;;  (interactive)
;;  (hs-minor-mode 1)
;;  (hs-hide-all))
;;
;;(defun ha/hs-toggle-hiding ()
;;  (interactive)
;;  (hs-minor-mode 1)
;;  (hs-toggle-hiding))
;; instead of C-c @
;;(use-package hs-minor-mode
;;  :bind
;;  ("C-c T h" . hs-minor-mode)
;;  ("C-c h a" . ha/hs-hide-all)
;;  ("C-c h s" . ha/hs-show-all)
;;  ("C-c h h" . ha/hs-toggle-hiding))

;; ha/aggroindent
(defun indent-defun ()
  "Indent current defun.
Do nothing if mark is active (to avoid deactivaing it), or if
buffer is not modified (to avoid creating accidental
modifications)."
  (interactive)
  (unless (or (region-active-p)
              buffer-read-only
              (null (buffer-modified-p)))
    (let ((l (save-excursion (beginning-of-defun 1) (point)))
          (r (save-excursion (end-of-defun 1) (point))))
      (cl-letf (((symbol-function 'message) #'ignore))
        (indent-region l r)))))
;;aggro/activate hook
;;(defun activate-aggressive-indent ()
;;  "Locally add `ha/indent-defun' to `post-command-hook'."
;;  (add-hook 'post-command-hook
;;            'indent-defun nil 'local))

;; red warnings
(add-hook 'prog-common-hook
          (lambda ()
            (font-lock-add-keywords nil
                                    '(("\\<\\(FIX\\|FIXME\\|TODO\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)))))

;; shell scripts
(add-tolist 'auto-mode-alist '("/bin/" . sh-mode)')

;; color-idents
;; https://github.com/ankurdave/color-identifiers-mode
;;(use-package color-identifiers-mode
;;  :ensure t
;;  :init
;;    (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)
;;  :diminish color-identifiers-mode)
;; color each var / downplay standard keywords...
;;(use-package color-identifiers-mode
;;  :ensure t
;;  :init
;;  (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode))

;; lamda pretty
;;(use-package lisp-mode
;;  :init
;;  (defconst lisp--prettify-symbols-alist
;;    '(("lambda"  . ?λ)
;;      ("."       . ?•)))
;;  :config
;;  (add-hook 'emacs-lisp-mode-hook 'global-prettify-symbols-mode)
;;  (add-hook 'emacs-lisp-mode-hook 'activate-aggressive-indent))

;; paredit
;; https://www.emacswiki.org/emacs/ParEdit
;; https://www.emacswiki.org/emacs/PareditCheatsheet
;;(use-package paredit
;;  :ensure t
;;  :diminish paredit-mode
;;  :init
;;    (add-hook 'emacs-lisp-mode-hook 'paredit-mode))

;; showparen
;; https://www.emacswiki.org/emacs/ShowParenMode
;;(use-package paren
;;  :init
;;  (set-face-background 'show-paren-match (face-background 'default))
;;  (set-face-foreground 'show-paren-match "#afa")
;;  (set-face-attribute  'show-paren-match nil :weight 'black)
;;  (set-face-background 'show-paren-mismatch (face-background 'default))
;;  (set-face-foreground 'show-paren-mismatch "#c66")
;;  (set-face-attribute  'show-paren-mismatch nil :weight 'black))
;;parendim
;;(use-package paren-face
;;  :ensure t
;;  :init
;;  (global-paren-face-mode))

;; eval s.expr => comment results
;;(use-package lisp-mode
;;  :config (defun eval-and-comment-output ()
;;            "Add the output of the sexp as a comment after the sexp"
;;            (interactive)
;;            (save-excursion
;;              (end-of-line)
;;              (condition-case nil
;;                  (princ (concat " ; -> " (pp-to-string (eval (preceding-sexp))))
;;                         (current-buffer))
;;                (error (message "Invalid expression")))))
;;
;;  :bind ("C-x e" . eval-and-comment-output))


;;https://github.com/howardabrams/dot-files/blob/master/emacs-clojure.org
;;https://github.com/howardabrams/dot-files/blob/master/emacs-ruby.org
;;https://github.com/howardabrams/dot-files/blob/master/emacs-python.org
;;https://github.com/howardabrams/dot-files/blob/master/emacs-javascript.org
;;https://github.com/howardabrams/dot-files/blob/master/emacs-web.org
;;(require 'init-clojure)
;;(require 'init-python)
;;(require 'init-ruby)
;;(require 'init-javascript)
;;(require 'init-web)

;; ha/orgmode.el
;; https://github.com/howardabrams/dot-files/blob/master/emacs-org.org

;; ha/jabber.el
;;(use-package jabber
;;  :ensure t
;;  :commands jabber-connect-all jabber-chat-with
;;  :init
;;  (define-key personal-global-map (kbd "a") 'jabber-connect-all)
;;  (define-key personal-global-map (kbd "j") 'jabber-chat-with)
;;  :config
;;  (setq starttls-use-gnutls t
;;        starttls-gnutls-program "gnutls-cli"
;;        starttls-extra-arguments '("--starttls" "--insecure")
;;
;;        jabber-history-enabled t
;;        jabber-use-global-history nil
;;        jabber-backlog-number 40
;;        jabber-backlog-days 30)
;;
;;  (defun my-jabber-chat-delete-or-bury ()
;;    (interactive)
;;    (if (eq 'jabber-chat-mode major-mode)
;;        (condition-case e
;;            (delete-frame)
;;          (error
;;           (if (string= "Attempt to delete the sole visible or iconified frame"
;;                        (cadr e))
;;               (bury-buffer))))))
;;
;;  (define-key jabber-chat-mode-map [escape] 'my-jabber-chat-delete-or-bury))
;;https://www.emacswiki.org/emacs/JabberEl

;; ha/markdown
;;(use-package markdown-mode
;;  :ensure t
;;  :mode ("\\.\\(m\\(ark\\)?down\\|md\\)$" . markdown-mode)
;;  :config
;;  (bind-key "A-b" (surround-text-with "+*") markdown-mode-map)
;;  (bind-key "s-b" (surround-text-with "**") markdown-mode-map)
;;  (bind-key "A-i" (surround-text-with "*") markdown-mode-map)
;;  (bind-key "s-i" (surround-text-with "*") markdown-mode-map)
;;  (bind-key "A-=" (surround-text-with "`") markdown-mode-map)
;;  (bind-key "s-=" (surround-text-with "`") markdown-mode-map))

;;git-gutter-fringe.el
;;https://github.com/syohex/emacs-git-gutter-fringe
(use-package git-gutter-fringe
   :ensure t
   :config (git-gutter-mode 1))

(use-package gitconfig-mode
   :ensure t)

(use-package gitignore-mode
   :ensure t)
;; run mo-git-blame-current
(use-package mo-git-blame
  :ensure t)

;; ha/magit
;; https://www.youtube.com/watch?v=vQO7F2Q9DwA
;;(use-package magit
;;  :ensure t
;;  :commands magit-status magit-blame
;;  :init
;;  (defadvice magit-status (around magit-fullscreen activate)
;;    (window-configuration-to-register :magit-fullscreen)
;;    ad-do-it
;;    (delete-other-windows))
;;  :config
;;  (setq magit-branch-arguments nil
;;        ;; use ido to look for branches
;;        magit-completing-read-function 'magit-ido-completing-read
;;        ;; don't put "origin-" in front of new branch names by default
;;        magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
;;        magit-push-always-verify nil
;;        ;; Get rid of the previous advice to go into fullscreen
;;        magit-restore-window-configuration t)
;;
;;  :bind ("C-x g" . magit-status))
